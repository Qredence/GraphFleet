// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __rest } from "tslib";
/**
 * THIS IS AN AUTO-GENERATED FILE - DO NOT EDIT!
 *
 * Any changes you make here may be lost.
 *
 * If you need to make changes, please do so in the original source file, \{project-root\}/sources/custom
 */
import { isTokenCredential } from "@azure/core-auth";
import { createAssistants } from "./api/AssistantsContext.js";
import { cancelRun, createAssistant, createAssistantFile, createMessage, createRun, createThread, createThreadAndRun, deleteAssistant, deleteAssistantFile, deleteFile, deleteThread, getAssistant, getAssistantFile, getFile, getMessage, getMessageFile, getRun, getRunStep, getThread, listAssistantFiles, listAssistants, listFiles, listMessageFiles, listMessages, listRunSteps, listRuns, submitToolOutputsToRun, updateAssistant, updateMessage, updateRun, updateThread, uploadFile, } from "./api/index.js";
import { nonAzurePolicy } from "./api/policies/nonAzure.js";
/** Client handling assistant-related operations. */
export class AssistantsClient {
    constructor(endpointOrOpenAiKey, credOrOptions = {}, options = {}) {
        var _a, _b;
        this._isAzure = false;
        let opts;
        let endpoint;
        let cred;
        if (isCred(credOrOptions)) {
            endpoint = endpointOrOpenAiKey;
            cred = credOrOptions;
            opts = options;
            this._isAzure = true;
        }
        else {
            endpoint = createOpenAIEndpoint(1);
            cred = endpointOrOpenAiKey;
            const { credentials } = credOrOptions, restOpts = __rest(credOrOptions, ["credentials"]);
            opts = Object.assign({ baseUrl: endpoint, credentials: {
                    apiKeyHeaderName: (_a = credentials === null || credentials === void 0 ? void 0 : credentials.apiKeyHeaderName) !== null && _a !== void 0 ? _a : "Authorization",
                    scopes: credentials === null || credentials === void 0 ? void 0 : credentials.scopes,
                } }, restOpts);
        }
        this._client = createAssistants(endpoint, cred, Object.assign(Object.assign({}, opts), (this._isAzure
            ? {}
            : {
                additionalPolicies: [
                    ...((_b = opts.additionalPolicies) !== null && _b !== void 0 ? _b : []),
                    {
                        position: "perCall",
                        policy: nonAzurePolicy(),
                    },
                ],
            })));
        this.pipeline = this._client.pipeline;
    }
    /** Creates a new assistant. */
    createAssistant(body, options = { requestOptions: {} }) {
        return createAssistant(this._client, body, options);
    }
    /** Gets a list of assistants that were previously created. */
    listAssistants(options = { requestOptions: {} }) {
        return listAssistants(this._client, options);
    }
    /** Retrieves an existing assistant. */
    getAssistant(assistantId, options = { requestOptions: {} }) {
        return getAssistant(this._client, assistantId, options);
    }
    /** Modifies an existing assistant. */
    updateAssistant(assistantId, body, options = { requestOptions: {} }) {
        return updateAssistant(this._client, assistantId, body, options);
    }
    /** Deletes an assistant. */
    deleteAssistant(assistantId, options = { requestOptions: {} }) {
        return deleteAssistant(this._client, assistantId, options);
    }
    /** Attaches a previously uploaded file to an assistant for use by tools that can read files. */
    createAssistantFile(assistantId, fileId, options = { requestOptions: {} }) {
        return createAssistantFile(this._client, assistantId, fileId, options);
    }
    /** Gets a list of files attached to a specific assistant, as used by tools that can read files. */
    listAssistantFiles(assistantId, options = { requestOptions: {} }) {
        return listAssistantFiles(this._client, assistantId, options);
    }
    /** Retrieves a file attached to an assistant. */
    getAssistantFile(assistantId, fileId, options = { requestOptions: {} }) {
        return getAssistantFile(this._client, assistantId, fileId, options);
    }
    /**
     * Unlinks a previously attached file from an assistant, rendering it unavailable for use by tools that can read
     * files.
     */
    deleteAssistantFile(assistantId, fileId, options = { requestOptions: {} }) {
        return deleteAssistantFile(this._client, assistantId, fileId, options);
    }
    /** Creates a new thread. Threads contain messages and can be run by assistants. */
    createThread(body = {}, options = { requestOptions: {} }) {
        return createThread(this._client, body, options);
    }
    /** Gets information about an existing thread. */
    getThread(threadId, options = { requestOptions: {} }) {
        return getThread(this._client, threadId, options);
    }
    /** Modifies an existing thread. */
    updateThread(threadId, options = { requestOptions: {} }) {
        return updateThread(this._client, threadId, options);
    }
    /** Deletes an existing thread. */
    deleteThread(threadId, options = { requestOptions: {} }) {
        return deleteThread(this._client, threadId, options);
    }
    /** Creates a new message on a specified thread. */
    createMessage(threadId, role, content, options = { requestOptions: {} }) {
        return createMessage(this._client, threadId, role, content, options);
    }
    /** Gets a list of messages that exist on a thread. */
    listMessages(threadId, options = { requestOptions: {} }) {
        return listMessages(this._client, threadId, options);
    }
    /** Gets an existing message from an existing thread. */
    getMessage(threadId, messageId, options = { requestOptions: {} }) {
        return getMessage(this._client, threadId, messageId, options);
    }
    /** Modifies an existing message on an existing thread. */
    updateMessage(threadId, messageId, options = { requestOptions: {} }) {
        return updateMessage(this._client, threadId, messageId, options);
    }
    /** Gets a list of previously uploaded files associated with a message from a thread. */
    listMessageFiles(threadId, messageId, options = { requestOptions: {} }) {
        return listMessageFiles(this._client, threadId, messageId, options);
    }
    /** Gets information about a file attachment to a message within a thread. */
    getMessageFile(threadId, messageId, fileId, options = { requestOptions: {} }) {
        return getMessageFile(this._client, threadId, messageId, fileId, options);
    }
    /** Creates a new run for an assistant thread. */
    createRun(threadId, createRunOptions, options = { requestOptions: {} }) {
        return createRun(this._client, threadId, createRunOptions, options);
    }
    /** Gets a list of runs for a specified thread. */
    listRuns(threadId, options = { requestOptions: {} }) {
        return listRuns(this._client, threadId, options);
    }
    /** Gets an existing run from an existing thread. */
    getRun(threadId, runId, options = { requestOptions: {} }) {
        return getRun(this._client, threadId, runId, options);
    }
    /** Modifies an existing thread run. */
    updateRun(threadId, runId, options = { requestOptions: {} }) {
        return updateRun(this._client, threadId, runId, options);
    }
    /** Submits outputs from tools as requested by tool calls in a run. Runs that need submitted tool outputs will have a status of 'requires_action' with a required_action.type of 'submit_tool_outputs'. */
    submitToolOutputsToRun(threadId, runId, toolOutputs, options = { requestOptions: {} }) {
        return submitToolOutputsToRun(this._client, threadId, runId, toolOutputs, options);
    }
    /** Cancels a run of an in progress thread. */
    cancelRun(threadId, runId, options = { requestOptions: {} }) {
        return cancelRun(this._client, threadId, runId, options);
    }
    /** Creates a new assistant thread and immediately starts a run using that new thread. */
    createThreadAndRun(body, options = { requestOptions: {} }) {
        return createThreadAndRun(this._client, body, options);
    }
    /** Gets a single run step from a thread run. */
    getRunStep(threadId, runId, stepId, options = { requestOptions: {} }) {
        return getRunStep(this._client, threadId, runId, stepId, options);
    }
    /** Gets a list of run steps from a thread run. */
    listRunSteps(threadId, runId, options = { requestOptions: {} }) {
        return listRunSteps(this._client, threadId, runId, options);
    }
    /** Gets a list of previously uploaded files. */
    listFiles(options = { requestOptions: {} }) {
        return listFiles(this._client, options);
    }
    /** Uploads a file for use by other operations. */
    uploadFile(file, purpose, options = { requestOptions: {} }) {
        return uploadFile(this._client, file, purpose, options);
    }
    /** Delete a previously uploaded file. */
    deleteFile(fileId, options = { requestOptions: {} }) {
        return deleteFile(this._client, fileId, options);
    }
    /** Returns information about a specific file. Does not retrieve file content. */
    getFile(fileId, options = { requestOptions: {} }) {
        return getFile(this._client, fileId, options);
    }
}
function createOpenAIEndpoint(version) {
    return `https://api.openai.com/v${version}`;
}
function isCred(cred) {
    return isTokenCredential(cred) || cred.key !== undefined;
}
//# sourceMappingURL=assistantsClient.js.map