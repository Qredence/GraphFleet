// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __rest } from "tslib";
/**
 * THIS IS AN AUTO-GENERATED FILE - DO NOT EDIT!
 *
 * Any changes you make here may be lost.
 *
 * If you need to make changes, please do so in the original source file, \{project-root\}/sources/custom
 */
import { createRestError, operationOptionsToRequestParameters, } from "@azure-rest/core-client";
import { createFile } from "@azure/core-rest-pipeline";
import { parseToolCallOutput, parseRequiredToolCallOutput } from "../models/helpers.js";
import { camelCaseKeys, unixToDate } from "./util.js";
export function _createAssistantSend(context, body, options = { requestOptions: {} }) {
    return context.path("/assistants").post(Object.assign(Object.assign({}, operationOptionsToRequestParameters(options)), { body: {
            model: body["model"],
            name: body["name"],
            description: body["description"],
            instructions: body["instructions"],
            tools: body["tools"],
            file_ids: body["fileIds"],
            metadata: body["metadata"],
        } }));
}
export async function _createAssistantDeserialize(result) {
    if (result.status !== "200") {
        throw createRestError(result);
    }
    return {
        id: result.body["id"],
        createdAt: unixToDate(result.body["created_at"]),
        name: result.body["name"],
        description: result.body["description"],
        model: result.body["model"],
        instructions: result.body["instructions"],
        tools: result.body["tools"],
        fileIds: result.body["file_ids"],
        metadata: result.body["metadata"],
    };
}
/** Creates a new assistant. */
export async function createAssistant(context, body, options = { requestOptions: {} }) {
    const result = await _createAssistantSend(context, body, options);
    return _createAssistantDeserialize(result);
}
export function _listAssistantsSend(context, options = { requestOptions: {} }) {
    return context.path("/assistants").get(Object.assign(Object.assign({}, operationOptionsToRequestParameters(options)), { queryParameters: {
            limit: options === null || options === void 0 ? void 0 : options.limit,
            order: options === null || options === void 0 ? void 0 : options.order,
            after: options === null || options === void 0 ? void 0 : options.after,
            before: options === null || options === void 0 ? void 0 : options.before,
        } }));
}
export function _getAssistantSend(context, assistantId, options = { requestOptions: {} }) {
    return context
        .path("/assistants/{assistantId}", assistantId)
        .get(Object.assign({}, operationOptionsToRequestParameters(options)));
}
export async function _getAssistantDeserialize(result) {
    if (result.status !== "200") {
        throw createRestError(result);
    }
    return {
        id: result.body["id"],
        createdAt: unixToDate(result.body["created_at"]),
        name: result.body["name"],
        description: result.body["description"],
        model: result.body["model"],
        instructions: result.body["instructions"],
        tools: result.body["tools"],
        fileIds: result.body["file_ids"],
        metadata: result.body["metadata"],
    };
}
/** Retrieves an existing assistant. */
export async function getAssistant(context, assistantId, options = { requestOptions: {} }) {
    const result = await _getAssistantSend(context, assistantId, options);
    return _getAssistantDeserialize(result);
}
export function _updateAssistantSend(context, assistantId, body, options = { requestOptions: {} }) {
    return context.path("/assistants/{assistantId}", assistantId).post(Object.assign(Object.assign({}, operationOptionsToRequestParameters(options)), { body: {
            model: body["model"],
            name: body["name"],
            description: body["description"],
            instructions: body["instructions"],
            tools: body["tools"],
            file_ids: body["fileIds"],
            metadata: body["metadata"],
        } }));
}
export async function _updateAssistantDeserialize(result) {
    if (result.status !== "200") {
        throw createRestError(result);
    }
    return {
        id: result.body["id"],
        createdAt: unixToDate(result.body["created_at"]),
        name: result.body["name"],
        description: result.body["description"],
        model: result.body["model"],
        instructions: result.body["instructions"],
        tools: result.body["tools"],
        fileIds: result.body["file_ids"],
        metadata: result.body["metadata"],
    };
}
/** Modifies an existing assistant. */
export async function updateAssistant(context, assistantId, body, options = { requestOptions: {} }) {
    const result = await _updateAssistantSend(context, assistantId, body, options);
    return _updateAssistantDeserialize(result);
}
export function _deleteAssistantSend(context, assistantId, options = { requestOptions: {} }) {
    return context
        .path("/assistants/{assistantId}", assistantId)
        .delete(Object.assign({}, operationOptionsToRequestParameters(options)));
}
export async function _deleteAssistantDeserialize(result) {
    if (result.status !== "200") {
        throw createRestError(result);
    }
    return {
        id: result.body["id"],
        deleted: result.body["deleted"],
    };
}
/** Deletes an assistant. */
export async function deleteAssistant(context, assistantId, options = { requestOptions: {} }) {
    const result = await _deleteAssistantSend(context, assistantId, options);
    return _deleteAssistantDeserialize(result);
}
export function _createAssistantFileSend(context, assistantId, fileId, options = { requestOptions: {} }) {
    return context.path("/assistants/{assistantId}/files", assistantId).post(Object.assign(Object.assign({}, operationOptionsToRequestParameters(options)), { body: { file_id: fileId } }));
}
export async function _createAssistantFileDeserialize(result) {
    if (result.status !== "200") {
        throw createRestError(result);
    }
    return {
        id: result.body["id"],
        createdAt: unixToDate(result.body["created_at"]),
        assistantId: result.body["assistant_id"],
    };
}
/** Attaches a previously uploaded file to an assistant for use by tools that can read files. */
export async function createAssistantFile(context, assistantId, fileId, options = { requestOptions: {} }) {
    const result = await _createAssistantFileSend(context, assistantId, fileId, options);
    return _createAssistantFileDeserialize(result);
}
export function _listAssistantFilesSend(context, assistantId, options = { requestOptions: {} }) {
    return context.path("/assistants/{assistantId}/files", assistantId).get(Object.assign(Object.assign({}, operationOptionsToRequestParameters(options)), { queryParameters: {
            limit: options === null || options === void 0 ? void 0 : options.limit,
            order: options === null || options === void 0 ? void 0 : options.order,
            after: options === null || options === void 0 ? void 0 : options.after,
            before: options === null || options === void 0 ? void 0 : options.before,
        } }));
}
export function _getAssistantFileSend(context, assistantId, fileId, options = { requestOptions: {} }) {
    return context
        .path("/assistants/{assistantId}/files/{fileId}", assistantId, fileId)
        .get(Object.assign({}, operationOptionsToRequestParameters(options)));
}
export async function _getAssistantFileDeserialize(result) {
    if (result.status !== "200") {
        throw createRestError(result);
    }
    return {
        id: result.body["id"],
        createdAt: unixToDate(result.body["created_at"]),
        assistantId: result.body["assistant_id"],
    };
}
/** Retrieves a file attached to an assistant. */
export async function getAssistantFile(context, assistantId, fileId, options = { requestOptions: {} }) {
    const result = await _getAssistantFileSend(context, assistantId, fileId, options);
    return _getAssistantFileDeserialize(result);
}
export function _deleteAssistantFileSend(context, assistantId, fileId, options = { requestOptions: {} }) {
    return context
        .path("/assistants/{assistantId}/files/{fileId}", assistantId, fileId)
        .delete(Object.assign({}, operationOptionsToRequestParameters(options)));
}
export async function _deleteAssistantFileDeserialize(result) {
    if (result.status !== "200") {
        throw createRestError(result);
    }
    return {
        id: result.body["id"],
        deleted: result.body["deleted"],
    };
}
/**
 * Unlinks a previously attached file from an assistant, rendering it unavailable for use by tools that can read
 * files.
 */
export async function deleteAssistantFile(context, assistantId, fileId, options = { requestOptions: {} }) {
    const result = await _deleteAssistantFileSend(context, assistantId, fileId, options);
    return _deleteAssistantFileDeserialize(result);
}
export async function _createThreadDeserialize(result) {
    if (result.status !== "200") {
        throw createRestError(result);
    }
    return {
        id: result.body["id"],
        createdAt: unixToDate(result.body["created_at"]),
        metadata: result.body["metadata"],
    };
}
/** Creates a new thread. Threads contain messages and can be run by assistants. */
export async function createThread(context, body, options = { requestOptions: {} }) {
    const result = await _createThreadSend(context, body, options);
    return _createThreadDeserialize(result);
}
export function _getThreadSend(context, threadId, options = { requestOptions: {} }) {
    return context
        .path("/threads/{threadId}", threadId)
        .get(Object.assign({}, operationOptionsToRequestParameters(options)));
}
export async function _getThreadDeserialize(result) {
    if (result.status !== "200") {
        throw createRestError(result);
    }
    return {
        id: result.body["id"],
        createdAt: unixToDate(result.body["created_at"]),
        metadata: result.body["metadata"],
    };
}
/** Gets information about an existing thread. */
export async function getThread(context, threadId, options = { requestOptions: {} }) {
    const result = await _getThreadSend(context, threadId, options);
    return _getThreadDeserialize(result);
}
export function _updateThreadSend(context, threadId, options = { requestOptions: {} }) {
    return context.path("/threads/{threadId}", threadId).post(Object.assign(Object.assign({}, operationOptionsToRequestParameters(options)), { body: { metadata: options === null || options === void 0 ? void 0 : options.metadata } }));
}
export async function _updateThreadDeserialize(result) {
    if (result.status !== "200") {
        throw createRestError(result);
    }
    return {
        id: result.body["id"],
        createdAt: unixToDate(result.body["created_at"]),
        metadata: result.body["metadata"],
    };
}
/** Modifies an existing thread. */
export async function updateThread(context, threadId, options = { requestOptions: {} }) {
    const result = await _updateThreadSend(context, threadId, options);
    return _updateThreadDeserialize(result);
}
export function _deleteThreadSend(context, threadId, options = { requestOptions: {} }) {
    return context
        .path("/threads/{threadId}", threadId)
        .delete(Object.assign({}, operationOptionsToRequestParameters(options)));
}
export async function _deleteThreadDeserialize(result) {
    if (result.status !== "200") {
        throw createRestError(result);
    }
    return {
        id: result.body["id"],
        deleted: result.body["deleted"],
    };
}
/** Deletes an existing thread. */
export async function deleteThread(context, threadId, options = { requestOptions: {} }) {
    const result = await _deleteThreadSend(context, threadId, options);
    return _deleteThreadDeserialize(result);
}
export function _createMessageSend(context, threadId, role, content, options = { requestOptions: {} }) {
    return context.path("/threads/{threadId}/messages", threadId).post(Object.assign(Object.assign({}, operationOptionsToRequestParameters(options)), { body: {
            role: role,
            content: content,
            file_ids: options === null || options === void 0 ? void 0 : options.fileIds,
            metadata: options === null || options === void 0 ? void 0 : options.metadata,
        } }));
}
/** Creates a new message on a specified thread. */
export async function createMessage(context, threadId, role, content, options = { requestOptions: {} }) {
    const result = await _createMessageSend(context, threadId, role, content, options);
    return _createMessageDeserialize(result);
}
export function _listMessagesSend(context, threadId, options = { requestOptions: {} }) {
    return context.path("/threads/{threadId}/messages", threadId).get(Object.assign(Object.assign({}, operationOptionsToRequestParameters(options)), { queryParameters: {
            limit: options === null || options === void 0 ? void 0 : options.limit,
            order: options === null || options === void 0 ? void 0 : options.order,
            after: options === null || options === void 0 ? void 0 : options.after,
            before: options === null || options === void 0 ? void 0 : options.before,
        } }));
}
export function _updateMessageSend(context, threadId, messageId, options = { requestOptions: {} }) {
    return context.path("/threads/{threadId}/messages/{messageId}", threadId, messageId).post(Object.assign(Object.assign({}, operationOptionsToRequestParameters(options)), { body: { metadata: options === null || options === void 0 ? void 0 : options.metadata } }));
}
/** Modifies an existing message on an existing thread. */
export async function updateMessage(context, threadId, messageId, options = { requestOptions: {} }) {
    const result = await _updateMessageSend(context, threadId, messageId, options);
    return _updateMessageDeserialize(result);
}
export function _listMessageFilesSend(context, threadId, messageId, options = { requestOptions: {} }) {
    return context.path("/threads/{threadId}/messages/{messageId}/files", threadId, messageId).get(Object.assign(Object.assign({}, operationOptionsToRequestParameters(options)), { queryParameters: {
            limit: options === null || options === void 0 ? void 0 : options.limit,
            order: options === null || options === void 0 ? void 0 : options.order,
            after: options === null || options === void 0 ? void 0 : options.after,
            before: options === null || options === void 0 ? void 0 : options.before,
        } }));
}
export function _getMessageFileSend(context, threadId, messageId, fileId, options = { requestOptions: {} }) {
    return context
        .path("/threads/{threadId}/messages/{messageId}/files/{fileId}", threadId, messageId, fileId)
        .get(Object.assign({}, operationOptionsToRequestParameters(options)));
}
export async function _getMessageFileDeserialize(result) {
    if (result.status !== "200") {
        throw createRestError(result);
    }
    return {
        id: result.body["id"],
        createdAt: unixToDate(result.body["created_at"]),
        messageId: result.body["message_id"],
    };
}
/** Gets information about a file attachment to a message within a thread. */
export async function getMessageFile(context, threadId, messageId, fileId, options = { requestOptions: {} }) {
    const result = await _getMessageFileSend(context, threadId, messageId, fileId, options);
    return _getMessageFileDeserialize(result);
}
export function _createRunSend(context, threadId, createRunOptions, options = { requestOptions: {} }) {
    return context.path("/threads/{threadId}/runs", threadId).post(Object.assign(Object.assign({}, operationOptionsToRequestParameters(options)), { body: {
            assistant_id: createRunOptions["assistantId"],
            model: createRunOptions["model"],
            instructions: createRunOptions["instructions"],
            additional_instructions: createRunOptions["additionalInstructions"],
            tools: createRunOptions["tools"],
            metadata: createRunOptions["metadata"],
        } }));
}
/** Creates a new run for an assistant thread. */
export async function createRun(context, threadId, createRunOptions, options = { requestOptions: {} }) {
    const result = await _createRunSend(context, threadId, createRunOptions, options);
    return _createRunDeserialize(result);
}
export function _listRunsSend(context, threadId, options = { requestOptions: {} }) {
    return context.path("/threads/{threadId}/runs", threadId).get(Object.assign(Object.assign({}, operationOptionsToRequestParameters(options)), { queryParameters: {
            limit: options === null || options === void 0 ? void 0 : options.limit,
            order: options === null || options === void 0 ? void 0 : options.order,
            after: options === null || options === void 0 ? void 0 : options.after,
            before: options === null || options === void 0 ? void 0 : options.before,
        } }));
}
export function _getRunSend(context, threadId, runId, options = { requestOptions: {} }) {
    return context
        .path("/threads/{threadId}/runs/{runId}", threadId, runId)
        .get(Object.assign({}, operationOptionsToRequestParameters(options)));
}
/** Gets an existing run from an existing thread. */
export async function getRun(context, threadId, runId, options = { requestOptions: {} }) {
    const result = await _getRunSend(context, threadId, runId, options);
    return _getRunDeserialize(result);
}
export function _updateRunSend(context, threadId, runId, options = { requestOptions: {} }) {
    return context.path("/threads/{threadId}/runs/{runId}", threadId, runId).post(Object.assign(Object.assign({}, operationOptionsToRequestParameters(options)), { body: { metadata: options === null || options === void 0 ? void 0 : options.metadata } }));
}
export async function _updateRunDeserialize(result) {
    if (result.status !== "200") {
        throw createRestError(result);
    }
    return {
        id: result.body["id"],
        threadId: result.body["thread_id"],
        assistantId: result.body["assistant_id"],
        status: result.body["status"],
        requiredAction: result.body.required_action,
        lastError: result.body.last_error,
        model: result.body["model"],
        instructions: result.body["instructions"],
        tools: result.body["tools"],
        fileIds: result.body["file_ids"],
        createdAt: unixToDate(result.body["created_at"]),
        expiresAt: result.body["expires_at"] === null ? null : unixToDate(Number(result.body["expires_at"])),
        startedAt: result.body["started_at"] === null ? null : unixToDate(Number(result.body["started_at"])),
        completedAt: result.body["completed_at"] === null ? null : unixToDate(Number(result.body["completed_at"])),
        cancelledAt: result.body["cancelled_at"] === null ? null : unixToDate(Number(result.body["cancelled_at"])),
        failedAt: result.body["failed_at"] === null ? null : unixToDate(Number(result.body["failed_at"])),
        metadata: result.body["metadata"],
    };
}
/** Modifies an existing thread run. */
export async function updateRun(context, threadId, runId, options = { requestOptions: {} }) {
    const result = await _updateRunSend(context, threadId, runId, options);
    return _updateRunDeserialize(result);
}
export function _submitToolOutputsToRunSend(context, threadId, runId, toolOutputs, options = { requestOptions: {} }) {
    return context
        .path("/threads/{threadId}/runs/{runId}/submit_tool_outputs", threadId, runId)
        .post(Object.assign(Object.assign({}, operationOptionsToRequestParameters(options)), { body: {
            tool_outputs: toolOutputs.map((p) => ({
                tool_call_id: p["toolCallId"],
                output: p["output"],
            })),
        } }));
}
/** Submits outputs from tools as requested by tool calls in a run. Runs that need submitted tool outputs will have a status of 'requires_action' with a required_action.type of 'submit_tool_outputs'. */
export async function submitToolOutputsToRun(context, threadId, runId, toolOutputs, options = { requestOptions: {} }) {
    const result = await _submitToolOutputsToRunSend(context, threadId, runId, toolOutputs, options);
    return _submitToolOutputsToRunDeserialize(result);
}
export function _cancelRunSend(context, threadId, runId, options = { requestOptions: {} }) {
    return context
        .path("/threads/{threadId}/runs/{runId}/cancel", threadId, runId)
        .post(Object.assign({}, operationOptionsToRequestParameters(options)));
}
/** Cancels a run of an in progress thread. */
export async function cancelRun(context, threadId, runId, options = { requestOptions: {} }) {
    const result = await _cancelRunSend(context, threadId, runId, options);
    return _cancelRunDeserialize(result);
}
/** Creates a new assistant thread and immediately starts a run using that new thread. */
export async function createThreadAndRun(context, body, options = { requestOptions: {} }) {
    const result = await _createThreadAndRunSend(context, body, options);
    return _createThreadAndRunDeserialize(result);
}
export function _getRunStepSend(context, threadId, runId, stepId, options = { requestOptions: {} }) {
    return context
        .path("/threads/{threadId}/runs/{runId}/steps/{stepId}", threadId, runId, stepId)
        .get(Object.assign({}, operationOptionsToRequestParameters(options)));
}
/** Gets a single run step from a thread run. */
export async function getRunStep(context, threadId, runId, stepId, options = { requestOptions: {} }) {
    const result = await _getRunStepSend(context, threadId, runId, stepId, options);
    return _getRunStepDeserialize(result);
}
export function _listRunStepsSend(context, threadId, runId, options = { requestOptions: {} }) {
    return context.path("/threads/{threadId}/runs/{runId}/steps", threadId, runId).get(Object.assign(Object.assign({}, operationOptionsToRequestParameters(options)), { queryParameters: {
            limit: options === null || options === void 0 ? void 0 : options.limit,
            order: options === null || options === void 0 ? void 0 : options.order,
            after: options === null || options === void 0 ? void 0 : options.after,
            before: options === null || options === void 0 ? void 0 : options.before,
        } }));
}
export function _listFilesSend(context, options = { requestOptions: {} }) {
    return context.path("/files").get(Object.assign(Object.assign({}, operationOptionsToRequestParameters(options)), { queryParameters: { purpose: options === null || options === void 0 ? void 0 : options.purpose } }));
}
export async function _listFilesDeserialize(result) {
    if (result.status !== "200") {
        throw createRestError(result);
    }
    return {
        data: result.body["data"].map((p) => ({
            id: p["id"],
            bytes: p["bytes"],
            filename: p["filename"],
            createdAt: unixToDate(p["created_at"]),
            purpose: p["purpose"],
        })),
    };
}
/** Gets a list of previously uploaded files. */
export async function listFiles(context, options = { requestOptions: {} }) {
    const result = await _listFilesSend(context, options);
    return _listFilesDeserialize(result);
}
/** Uploads a file for use by other operations. */
export async function uploadFile(context, file, purpose, options = { requestOptions: {} }) {
    const result = await _uploadFileSend(context, file, purpose, options);
    return _uploadFileDeserialize(result);
}
export function _deleteFileSend(context, fileId, options = { requestOptions: {} }) {
    return context
        .path("/files/{fileId}", fileId)
        .delete(Object.assign({}, operationOptionsToRequestParameters(options)));
}
export async function _deleteFileDeserialize(result) {
    if (result.status !== "200") {
        throw createRestError(result);
    }
    return {
        id: result.body["id"],
        deleted: result.body["deleted"],
    };
}
/** Delete a previously uploaded file. */
export async function deleteFile(context, fileId, options = { requestOptions: {} }) {
    const result = await _deleteFileSend(context, fileId, options);
    return _deleteFileDeserialize(result);
}
export function _getFileSend(context, fileId, options = { requestOptions: {} }) {
    return context
        .path("/files/{fileId}", fileId)
        .get(Object.assign({}, operationOptionsToRequestParameters(options)));
}
/** Returns information about a specific file. Does not retrieve file content. */
export async function getFile(context, fileId, options = { requestOptions: {} }) {
    const result = await _getFileSend(context, fileId, options);
    return _getFileDeserialize(result);
}
export async function _createRunDeserialize(result) {
    var _a, _b, _c;
    if (result.status !== "200") {
        throw createRestError(result);
    }
    const _d = result.body, { required_action, last_error, created_at, expires_at, started_at, completed_at, cancelled_at, failed_at } = _d, rest = __rest(_d, ["required_action", "last_error", "created_at", "expires_at", "started_at", "completed_at", "cancelled_at", "failed_at"]);
    return Object.assign(Object.assign({}, camelCaseKeys(rest)), { requiredAction: !required_action
            ? undefined
            : {
                type: required_action === null || required_action === void 0 ? void 0 : required_action["type"],
                submitToolOutputs: !((_a = required_action === null || required_action === void 0 ? void 0 : required_action.submit_tool_outputs) === null || _a === void 0 ? void 0 : _a["tool_calls"])
                    ? undefined
                    : {
                        toolCalls: (_c = (_b = required_action === null || required_action === void 0 ? void 0 : required_action.submit_tool_outputs) === null || _b === void 0 ? void 0 : _b.tool_calls) === null || _c === void 0 ? void 0 : _c.map(parseRequiredToolCallOutput),
                    },
            }, lastError: !last_error
            ? undefined
            : {
                code: last_error === null || last_error === void 0 ? void 0 : last_error["code"],
                message: last_error === null || last_error === void 0 ? void 0 : last_error["message"],
            }, createdAt: unixToDate(created_at), expiresAt: expires_at === null ? null : unixToDate(Number(expires_at)), startedAt: started_at === null ? null : unixToDate(Number(started_at)), completedAt: completed_at === null ? null : unixToDate(Number(completed_at)), cancelledAt: cancelled_at === null ? null : unixToDate(Number(cancelled_at)), failedAt: failed_at === null ? null : unixToDate(Number(failed_at)) });
}
export async function _listRunsDeserialize(result) {
    if (result.status !== "200") {
        throw createRestError(result);
    }
    return {
        data: result.body["data"].map((p) => {
            var _a, _b, _c;
            return ({
                id: p["id"],
                threadId: p["thread_id"],
                assistantId: p["assistant_id"],
                status: p["status"],
                requiredAction: !p.required_action ? undefined : { type: (_a = p.required_action) === null || _a === void 0 ? void 0 : _a["type"] },
                lastError: !p.last_error
                    ? undefined
                    : { code: (_b = p.last_error) === null || _b === void 0 ? void 0 : _b["code"], message: (_c = p.last_error) === null || _c === void 0 ? void 0 : _c["message"] },
                model: p["model"],
                instructions: p["instructions"],
                tools: p["tools"],
                fileIds: p["file_ids"],
                metadata: p["metadata"],
                createdAt: unixToDate(p["created_at"]),
                expiresAt: p["expires_at"] === null ? null : unixToDate(Number(p["expires_at"])),
                startedAt: p["started_at"] === null ? null : unixToDate(Number(p["started_at"])),
                completedAt: p["completed_at"] === null ? null : unixToDate(Number(p["completed_at"])),
                cancelledAt: p["cancelled_at"] === null ? null : unixToDate(Number(p["cancelled_at"])),
                failedAt: p["failed_at"] === null ? null : unixToDate(Number(p["failed_at"])),
            });
        }),
        firstId: result.body["first_id"],
        lastId: result.body["last_id"],
        hasMore: result.body["has_more"],
    };
}
export function _createThreadAndRunSend(context, body, options = { requestOptions: {} }) {
    var _a, _b, _c, _d;
    return context.path("/threads/runs").post(Object.assign(Object.assign({}, operationOptionsToRequestParameters(options)), { body: {
            assistant_id: body["assistantId"],
            thread: !body.thread
                ? undefined
                : {
                    messages: !((_a = body.thread) === null || _a === void 0 ? void 0 : _a["messages"])
                        ? (_b = body.thread) === null || _b === void 0 ? void 0 : _b["messages"]
                        : (_c = body.thread) === null || _c === void 0 ? void 0 : _c["messages"].map((p) => ({
                            role: p["role"],
                            content: p["content"],
                        })),
                    metadata: (_d = body.thread) === null || _d === void 0 ? void 0 : _d["metadata"],
                },
            model: body["model"],
            instructions: body["instructions"],
            tools: body["tools"],
            metadata: body["metadata"],
        } }));
}
/** Returns a list of runs associated with an assistant thread. */
export async function listRuns(context, threadId, options = { requestOptions: {} }) {
    const result = await _listRunsSend(context, threadId, options);
    return _listRunsDeserialize(result);
}
export async function _getRunDeserialize(result) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (result.status !== "200") {
        throw createRestError(result);
    }
    return {
        id: result.body["id"],
        threadId: result.body["thread_id"],
        assistantId: result.body["assistant_id"],
        status: result.body["status"],
        requiredAction: !result.body.required_action
            ? undefined
            : {
                type: (_a = result.body.required_action) === null || _a === void 0 ? void 0 : _a["type"],
                submitToolOutputs: !((_c = (_b = result.body.required_action) === null || _b === void 0 ? void 0 : _b.submit_tool_outputs) === null || _c === void 0 ? void 0 : _c["tool_calls"])
                    ? undefined
                    : {
                        toolCalls: (_f = (_e = (_d = result.body.required_action) === null || _d === void 0 ? void 0 : _d.submit_tool_outputs) === null || _e === void 0 ? void 0 : _e.tool_calls) === null || _f === void 0 ? void 0 : _f.map(parseRequiredToolCallOutput),
                    },
            },
        lastError: !result.body.last_error
            ? undefined
            : {
                code: (_g = result.body.last_error) === null || _g === void 0 ? void 0 : _g["code"],
                message: (_h = result.body.last_error) === null || _h === void 0 ? void 0 : _h["message"],
            },
        model: result.body["model"],
        instructions: result.body["instructions"],
        tools: result.body["tools"],
        fileIds: result.body["file_ids"],
        metadata: result.body["metadata"],
        createdAt: unixToDate(result.body["created_at"]),
        expiresAt: result.body["expires_at"] === null ? null : unixToDate(Number(result.body["expires_at"])),
        startedAt: result.body["started_at"] === null ? null : unixToDate(Number(result.body["started_at"])),
        completedAt: result.body["completed_at"] === null ? null : unixToDate(Number(result.body["completed_at"])),
        cancelledAt: result.body["cancelled_at"] === null ? null : unixToDate(Number(result.body["cancelled_at"])),
        failedAt: result.body["failed_at"] === null ? null : unixToDate(Number(result.body["failed_at"])),
    };
}
export async function _submitToolOutputsToRunDeserialize(result) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (result.status !== "200") {
        throw createRestError(result);
    }
    return {
        id: result.body["id"],
        threadId: result.body["thread_id"],
        assistantId: result.body["assistant_id"],
        status: result.body["status"],
        requiredAction: !result.body.required_action
            ? undefined
            : {
                type: (_a = result.body.required_action) === null || _a === void 0 ? void 0 : _a["type"],
                submitToolOutputs: !((_c = (_b = result.body.required_action) === null || _b === void 0 ? void 0 : _b.submit_tool_outputs) === null || _c === void 0 ? void 0 : _c["tool_calls"])
                    ? undefined
                    : {
                        toolCalls: (_f = (_e = (_d = result.body.required_action) === null || _d === void 0 ? void 0 : _d.submit_tool_outputs) === null || _e === void 0 ? void 0 : _e.tool_calls) === null || _f === void 0 ? void 0 : _f.map(parseRequiredToolCallOutput),
                    },
            },
        lastError: !result.body.last_error
            ? undefined
            : {
                code: (_g = result.body.last_error) === null || _g === void 0 ? void 0 : _g["code"],
                message: (_h = result.body.last_error) === null || _h === void 0 ? void 0 : _h["message"],
            },
        model: result.body["model"],
        instructions: result.body["instructions"],
        tools: result.body["tools"],
        fileIds: result.body["file_ids"],
        metadata: result.body["metadata"],
        createdAt: unixToDate(result.body["created_at"]),
        expiresAt: result.body["expires_at"] === null ? null : unixToDate(Number(result.body["expires_at"])),
        startedAt: result.body["started_at"] === null ? null : unixToDate(Number(result.body["started_at"])),
        completedAt: result.body["completed_at"] === null ? null : unixToDate(Number(result.body["completed_at"])),
        cancelledAt: result.body["cancelled_at"] === null ? null : unixToDate(Number(result.body["cancelled_at"])),
        failedAt: result.body["failed_at"] === null ? null : unixToDate(Number(result.body["failed_at"])),
    };
}
export async function _createThreadAndRunDeserialize(result) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (result.status !== "200") {
        throw createRestError(result);
    }
    return {
        id: result.body["id"],
        threadId: result.body["thread_id"],
        assistantId: result.body["assistant_id"],
        status: result.body["status"],
        requiredAction: !result.body.required_action
            ? undefined
            : {
                type: (_a = result.body.required_action) === null || _a === void 0 ? void 0 : _a["type"],
                submitToolOutputs: !((_c = (_b = result.body.required_action) === null || _b === void 0 ? void 0 : _b.submit_tool_outputs) === null || _c === void 0 ? void 0 : _c["tool_calls"])
                    ? undefined
                    : {
                        toolCalls: (_f = (_e = (_d = result.body.required_action) === null || _d === void 0 ? void 0 : _d.submit_tool_outputs) === null || _e === void 0 ? void 0 : _e.tool_calls) === null || _f === void 0 ? void 0 : _f.map(parseRequiredToolCallOutput),
                    },
            },
        lastError: !result.body.last_error
            ? undefined
            : {
                code: (_g = result.body.last_error) === null || _g === void 0 ? void 0 : _g["code"],
                message: (_h = result.body.last_error) === null || _h === void 0 ? void 0 : _h["message"],
            },
        model: result.body["model"],
        instructions: result.body["instructions"],
        tools: result.body["tools"],
        fileIds: result.body["file_ids"],
        metadata: result.body["metadata"],
        createdAt: unixToDate(result.body["created_at"]),
        expiresAt: result.body["expires_at"] === null ? null : unixToDate(Number(result.body["expires_at"])),
        startedAt: result.body["started_at"] === null ? null : unixToDate(Number(result.body["started_at"])),
        completedAt: result.body["completed_at"] === null ? null : unixToDate(Number(result.body["completed_at"])),
        cancelledAt: result.body["cancelled_at"] === null ? null : unixToDate(Number(result.body["cancelled_at"])),
        failedAt: result.body["failed_at"] === null ? null : unixToDate(Number(result.body["failed_at"])),
    };
}
export async function _cancelRunDeserialize(result) {
    var _a, _b, _c, _d, _e, _f;
    if (result.status !== "200") {
        throw createRestError(result);
    }
    return {
        id: result.body["id"],
        threadId: result.body["thread_id"],
        assistantId: result.body["assistant_id"],
        status: result.body["status"],
        requiredAction: !result.body.required_action
            ? undefined
            : {
                type: (_a = result.body.required_action) === null || _a === void 0 ? void 0 : _a["type"],
                submitToolOutputs: !((_c = (_b = result.body.required_action) === null || _b === void 0 ? void 0 : _b.submit_tool_outputs) === null || _c === void 0 ? void 0 : _c["tool_calls"])
                    ? undefined
                    : {
                        toolCalls: (_f = (_e = (_d = result.body.required_action) === null || _d === void 0 ? void 0 : _d.submit_tool_outputs) === null || _e === void 0 ? void 0 : _e.tool_calls) === null || _f === void 0 ? void 0 : _f.map(parseRequiredToolCallOutput),
                    },
            },
        lastError: !result.body.last_error
            ? undefined
            : {
                code: result.body.last_error["code"],
                message: result.body.last_error["message"],
            },
        model: result.body["model"],
        instructions: result.body["instructions"],
        tools: result.body["tools"],
        fileIds: result.body["file_ids"],
        createdAt: unixToDate(result.body["created_at"]),
        expiresAt: result.body["expires_at"] === null ? null : unixToDate(Number(result.body["expires_at"])),
        startedAt: result.body["started_at"] === null ? null : unixToDate(Number(result.body["started_at"])),
        completedAt: result.body["completed_at"] === null ? null : unixToDate(Number(result.body["completed_at"])),
        cancelledAt: result.body["cancelled_at"] === null ? null : unixToDate(Number(result.body["cancelled_at"])),
        failedAt: result.body["failed_at"] === null ? null : unixToDate(Number(result.body["failed_at"])),
        metadata: result.body["metadata"],
    };
}
export async function listMessages(context, threadId, options = { requestOptions: {} }) {
    const result = await _listMessagesSend(context, threadId, options);
    return _listMessagesDeserialize(result);
}
export function _getMessageSend(context, threadId, messageId, options = { requestOptions: {} }) {
    return context
        .path("/threads/{threadId}/messages/{messageId}", threadId, messageId)
        .get(Object.assign({}, operationOptionsToRequestParameters(options)));
}
/** Retrieves a message associated with a thread. */
export async function getMessage(context, threadId, messageId, options = { requestOptions: {} }) {
    const result = await _getMessageSend(context, threadId, messageId, options);
    return _getMessageDeserialize(result);
}
export async function _listMessageFilesDeserialize(result) {
    if (result.status !== "200") {
        throw createRestError(result);
    }
    return {
        data: result.body["data"].map((p) => ({
            id: p["id"],
            createdAt: unixToDate(p["created_at"]),
            messageId: p["message_id"],
        })),
        firstId: result.body["first_id"],
        lastId: result.body["last_id"],
        hasMore: result.body["has_more"],
    };
}
/** Returns a list of files associated with a message from a thread. */
export async function listMessageFiles(context, threadId, messageId, options = { requestOptions: {} }) {
    const result = await _listMessageFilesSend(context, threadId, messageId, options);
    return _listMessageFilesDeserialize(result);
}
export async function _createMessageDeserialize(result) {
    var _a;
    if (result.status !== "200") {
        throw createRestError(result);
    }
    return {
        id: result.body["id"],
        createdAt: unixToDate(result.body["created_at"]),
        threadId: result.body["thread_id"],
        role: result.body["role"],
        content: ((_a = result.body["content"]) !== null && _a !== void 0 ? _a : []).map(parseMessageContentOutput),
        assistantId: result.body["assistant_id"],
        runId: result.body["run_id"],
        fileIds: result.body["file_ids"],
        metadata: result.body["metadata"],
    };
}
export async function _listMessagesDeserialize(result) {
    var _a;
    if (result.status !== "200") {
        throw createRestError(result);
    }
    return {
        data: ((_a = result.body["data"]) !== null && _a !== void 0 ? _a : []).map((p) => {
            var _a;
            return ({
                id: p["id"],
                createdAt: unixToDate(p["created_at"]),
                threadId: p["thread_id"],
                role: p["role"],
                content: ((_a = p["content"]) !== null && _a !== void 0 ? _a : []).map(parseMessageContentOutput),
                assistantId: p["assistant_id"],
                runId: p["run_id"],
                metadata: p["metadata"],
            });
        }),
        firstId: result.body["first_id"],
        lastId: result.body["last_id"],
        hasMore: result.body["has_more"],
    };
}
export async function _getMessageDeserialize(result) {
    var _a;
    if (result.status !== "200") {
        throw createRestError(result);
    }
    return {
        id: result.body["id"],
        createdAt: unixToDate(result.body["created_at"]),
        threadId: result.body["thread_id"],
        role: result.body["role"],
        content: ((_a = result.body["content"]) !== null && _a !== void 0 ? _a : []).map(parseMessageContentOutput),
        assistantId: result.body["assistant_id"],
        runId: result.body["run_id"],
        metadata: result.body["metadata"],
    };
}
export async function _updateMessageDeserialize(result) {
    var _a;
    if (result.status !== "200") {
        throw createRestError(result);
    }
    return {
        id: result.body["id"],
        createdAt: unixToDate(result.body["created_at"]),
        threadId: result.body["thread_id"],
        role: result.body["role"],
        content: ((_a = result.body["content"]) !== null && _a !== void 0 ? _a : []).map(parseMessageContentOutput),
        assistantId: result.body["assistant_id"],
        runId: result.body["run_id"],
        metadata: result.body["metadata"],
    };
}
export async function _listRunStepsDeserialize(result) {
    if (result.status !== "200") {
        throw createRestError(result);
    }
    return {
        data: result.body["data"].map(parseRunStepOutput),
        firstId: result.body["first_id"],
        lastId: result.body["last_id"],
        hasMore: result.body["has_more"],
    };
}
export async function _getRunStepDeserialize(result) {
    if (result.status !== "200") {
        throw createRestError(result);
    }
    const _a = result.body, { step_details, last_error, created_at, expired_at, completed_at, cancelled_at, failed_at } = _a, rest = __rest(_a, ["step_details", "last_error", "created_at", "expired_at", "completed_at", "cancelled_at", "failed_at"]);
    return Object.assign(Object.assign({}, camelCaseKeys(rest)), { stepDetails: parseRunStepDetails(step_details), lastError: last_error === null
            ? null
            : {
                code: last_error["code"],
                message: last_error["message"],
            }, createdAt: unixToDate(created_at), expiredAt: expired_at === null ? null : unixToDate(Number(expired_at)), completedAt: completed_at === null ? null : unixToDate(Number(completed_at)), cancelledAt: cancelled_at === null ? null : unixToDate(Number(cancelled_at)), failedAt: failed_at === null ? null : unixToDate(Number(failed_at)) });
}
/** Returns a list of run steps associated an assistant thread run. */
export async function listRunSteps(context, threadId, runId, options = { requestOptions: {} }) {
    const result = await _listRunStepsSend(context, threadId, runId, options);
    return _listRunStepsDeserialize(result);
}
export async function _listAssistantsDeserialize(result) {
    if (result.status !== "200") {
        throw createRestError(result);
    }
    return {
        data: result.body["data"].map((p) => ({
            id: p["id"],
            createdAt: unixToDate(p["created_at"]),
            name: p["name"],
            description: p["description"],
            model: p["model"],
            instructions: p["instructions"],
            tools: p["tools"],
            fileIds: p["file_ids"],
            metadata: p["metadata"],
        })),
        firstId: result.body["first_id"],
        lastId: result.body["last_id"],
        hasMore: result.body["has_more"],
    };
}
/** Returns a list of assistants. */
export async function listAssistants(context, options = { requestOptions: {} }) {
    const result = await _listAssistantsSend(context, options);
    return _listAssistantsDeserialize(result);
}
export async function _listAssistantFilesDeserialize(result) {
    if (result.status !== "200") {
        throw createRestError(result);
    }
    return {
        data: result.body["data"].map((p) => ({
            id: p["id"],
            createdAt: unixToDate(p["created_at"]),
            assistantId: p["assistant_id"],
        })),
        firstId: result.body["first_id"],
        lastId: result.body["last_id"],
        hasMore: result.body["has_more"],
    };
}
/** Returns a list of assistant files. */
export async function listAssistantFiles(context, assistantId, options = { requestOptions: {} }) {
    const result = await _listAssistantFilesSend(context, assistantId, options);
    return _listAssistantFilesDeserialize(result);
}
export function _createThreadSend(context, body, options = { requestOptions: {} }) {
    var _a;
    return context.path("/threads").post(Object.assign(Object.assign({}, operationOptionsToRequestParameters(options)), { body: {
            messages: ((_a = body["messages"]) !== null && _a !== void 0 ? _a : []).map((p) => ({
                role: p["role"],
                content: p["content"],
            })),
            metadata: body["metadata"],
        } }));
}
export function _uploadFileSend(context, file, purpose, options = { requestOptions: {} }) {
    var _a;
    return context.path("/files").post(Object.assign(Object.assign({}, operationOptionsToRequestParameters(options)), { contentType: (_a = options.contentType) !== null && _a !== void 0 ? _a : "multipart/form-data", body: {
            file: createFile(file, (options === null || options === void 0 ? void 0 : options.filename) || "unknown.txt"),
            purpose: purpose,
        } }));
}
export async function _uploadFileDeserialize(result) {
    if (result.status !== "200") {
        throw createRestError(result);
    }
    return {
        id: result.body["id"],
        bytes: result.body["bytes"],
        filename: result.body["filename"],
        createdAt: unixToDate(result.body["created_at"]),
        purpose: result.body["purpose"],
    };
}
export async function _getFileDeserialize(result) {
    if (result.status !== "200") {
        throw createRestError(result);
    }
    return {
        id: result.body["id"],
        bytes: result.body["bytes"],
        filename: result.body["filename"],
        createdAt: unixToDate(result.body["created_at"]),
        purpose: result.body["purpose"],
    };
}
function parseMessageContentOutput(messageContentOutput) {
    const messageContent = { type: "", text: {}, imageFile: {} };
    switch (messageContentOutput.type) {
        case "image_file":
            messageContent.type = "image_file";
            messageContent.imageFile = messageContentOutput.image_file;
            break;
        case "text":
            messageContent.type = "text";
            messageContent.text = messageContentOutput.text;
            break;
    }
    return messageContent;
}
function parseRunStepDetails(runStepDetailsOutput) {
    const { type } = runStepDetailsOutput;
    const details = { type, messageCreation: {}, toolCalls: [] };
    switch (type) {
        case "message_creation":
            details.messageCreation = runStepDetailsOutput["message_creation"];
            break;
        case "tool_calls":
            details.toolCalls = runStepDetailsOutput["tool_calls"].map(parseToolCallOutput);
            break;
    }
    return details;
}
function parseRunStepOutput(runStepOutput) {
    const { step_details, last_error, created_at, expired_at, completed_at, cancelled_at, failed_at } = runStepOutput, rest = __rest(runStepOutput, ["step_details", "last_error", "created_at", "expired_at", "completed_at", "cancelled_at", "failed_at"]);
    return Object.assign(Object.assign({}, camelCaseKeys(rest)), { stepDetails: parseRunStepDetails(step_details), lastError: last_error === null ? null : { code: last_error["code"], message: last_error["message"] }, createdAt: unixToDate(created_at), expiredAt: expired_at === null ? null : unixToDate(Number(expired_at)), completedAt: completed_at === null ? null : unixToDate(Number(completed_at)), cancelledAt: cancelled_at === null ? null : unixToDate(Number(cancelled_at)), failedAt: failed_at === null ? null : unixToDate(Number(failed_at)) });
}
//# sourceMappingURL=operations.js.map