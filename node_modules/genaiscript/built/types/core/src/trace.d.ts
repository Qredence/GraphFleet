import { TraceTree } from "./markdown";
export declare class TraceChunkEvent extends Event {
    readonly chunk: string;
    constructor(chunk: string);
}
export declare class MarkdownTrace extends EventTarget implements ToolCallTrace {
    readonly errors: {
        message: string;
        error: SerializedError;
    }[];
    private detailsDepth;
    private _content;
    private _tree;
    constructor();
    private disableChangeDispatch;
    dispatchChange(): void;
    get tree(): TraceTree;
    get content(): string;
    appendContent(value: string): void;
    startDetails(title: string, success?: boolean): void;
    endDetails(): void;
    private disableChange;
    details(title: string, body: string | object): void;
    detailsFenced(title: string, body: string | object, contentType?: string): void;
    item(message: string): void;
    itemValue(name: string, value: any, unit?: string): void;
    log(message: string): void;
    startFence(language: string): void;
    endFence(): void;
    fence(message: string | unknown, contentType?: string): void;
    append(trace: MarkdownTrace): void;
    tip(message: string): void;
    heading(level: number, message: string): void;
    image(url: string, caption?: string): void;
    private toResultIcon;
    resultItem(value: boolean, message: string): void;
    error(message: string, error?: unknown): void;
    renderErrors(): void;
    private renderError;
    warn(msg: string): void;
    caution(msg: string): void;
    note(msg: string): void;
    files(files: WorkspaceFileWithScore[], options?: {
        model?: string;
        maxLength?: number;
        title?: string;
        skipIfEmpty?: boolean;
        secrets?: Record<string, string>;
    }): void;
}
export interface TraceOptions {
    trace?: MarkdownTrace;
}
export interface AbortSignalOptions {
    signal?: AbortSignal;
}
//# sourceMappingURL=trace.d.ts.map